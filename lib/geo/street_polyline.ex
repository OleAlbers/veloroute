defmodule Geo.StreetPolyline do
  @precision 6
  @autogen_file_path "data/auto_generated/street_polyline.ex"

  def generate_from_file(source) do
    content =
      source
      |> File.stream!()
      |> Parallel.flat_map(&parse_line/1)
      |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))
      |> Task.async_stream(&simplify/1, timeout: :infinity, ordered: false)
      |> Task.async_stream(&as_polyline/1, timeout: :infinity, ordered: false)
      |> Enum.into(%{}, &elem(&1, 1))
      |> as_code()

    :ok = Util.write_autogenerated_file(@autogen_file_path, content)
  end

  def encode(polyline), do: Polyline.encode(polyline, @precision)
  def decode(polyline), do: Polyline.decode(polyline, @precision)

  defp as_code(map) do
    quote do
      defmodule Data.AutoGenerated.StreetPolyline do
        @moduledoc """
        AUTOGENERATED. To update this file, run mix velo.search.generate_polylines.
        See Geo.StreetPolyline for functionality.

        The polylines are based on OSM, thus are licensed under the ODbL:
        https://www.openstreetmap.org/copyright
        """
        @map unquote(Macro.escape(map))

        def get(val), do: Map.get(@map, val)
      end
    end
    |> Macro.to_string()
    |> Code.format_string!()
  end

  defp parse_line(line) do
    # format is encoded polyline, streetname, potentially a street id ("A 37")
    [poly | names] = String.split(line, "\0")

    decoded =
      poly
      |> Polyline.decode(@precision)
      |> Enum.map(fn {lon, lat} ->
        # since we later want to compare the coordinates, ensure we have the
        # same rounding errors everywhere
        {Float.round(lon, @precision), Float.round(lat, @precision)}
      end)

    Enum.map(names, &{String.trim_trailing(&1), decoded})
  end

  defp as_polyline({:ok, {name, polylines}}) do
    {name, Enum.map(polylines, &Polyline.encode(&1, @precision))}
  end

  defp as_polyline({name, polylines}) do
    {name, Enum.map(polylines, &Polyline.encode(&1, @precision))}
  end

  # First split up the polylines into individual segments, removing any
  # duplicates. This is necessary since the polylines might self-overlap. Next,
  # join them again to reduce the amount of polylines needed. Since we don't
  # care about the route graph, this just saves bandwidth without losing any
  # details.
  defp simplify({name, polylines}) do
    segments =
      polylines
      |> Enum.flat_map(&Enum.chunk_every(&1, 2, 1, :discard))
      |> Enum.map(&Enum.sort/1)
      |> Enum.uniq()

    {name, simplify([], segments)}
  end

  defp simplify(finished, []), do: finished
  defp simplify(finished, [poly]), do: [poly | finished]

  defp simplify(finished, [poly | rest]) do
    case Enum.find_value(rest, &join(poly, &1)) do
      {joined, other} ->
        rest = List.delete(rest, other)
        simplify(finished, [joined | rest])

      nil ->
        simplify([poly | finished], rest)
    end
  end

  defp join(poly, poly),
    do: raise("There are duplicated polylines in the input")

  defp join(poly, other) do
    [s1 | tl1] = poly
    [s2 | tl2] = other
    e1 = List.last(poly)
    e2 = List.last(other)

    joined =
      cond do
        s1 == s2 -> Enum.reverse(tl1) ++ other
        s1 == e2 -> other ++ tl1
        s2 == e1 -> poly ++ tl2
        e1 == e2 -> poly ++ tl(Enum.reverse(other))
        true -> nil
      end

    if joined,
      do: {joined, other},
      else: nil
  end
end
