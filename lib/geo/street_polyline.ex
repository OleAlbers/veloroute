defmodule Geo.StreetPolyline do
  @precision 6
  @autogen_file_path "data/auto_generated/street_polyline.ex"

  def generate_from_file(source) do
    content =
      source
      |> File.stream!()
      |> Stream.flat_map(&parse_line/1)
      |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))
      |> Enum.map(&join_all/1)
      |> Enum.map(&as_polyline/1)
      |> Enum.into(%{})
      |> as_code()

    with :ok <- File.write(@autogen_file_path, content),
         {:ok, _modules, _warnings} <- Kernel.ParallelCompiler.compile([@autogen_file_path], []) do
      :ok
    end
  end

  def encode(polyline), do: Polyline.encode(polyline, @precision)
  def decode(polyline), do: Polyline.decode(polyline, @precision)

  defp as_code(map) do
    quote do
      defmodule Data.AutoGenerated.StreetPolyline do
        @moduledoc """
        AUTOGENERATED. To update this file, run mix velo.search.generate_polylines.
        See Geo.StreetPolyline for functionality.

        The polylines are based on OSM, thus are licensed under the ODbL:
        https://www.openstreetmap.org/copyright
        """
        @map unquote(Macro.escape(map))

        def get(val), do: Map.get(@map, val)
      end
    end
    |> Macro.to_string()
    |> Code.format_string!()
  end

  defp parse_line(line) do
    # format is encoded polyline, streetname, potentially a street id ("A 37")
    [poly | names] = String.split(line, "\0")
    Enum.map(names, &{String.trim_trailing(&1), Polyline.decode(poly, @precision)})
  end

  defp as_polyline({name, polylines}) do
    {name, Enum.map(polylines, &Polyline.encode(&1, @precision))}
  end

  # since the original purpose is a route graph, we can join the individual
  # elements. Since we only need to display the lines, we can use this to reduce
  # data stored.
  defp join_all({name, polylines}) do
    {joined, kept} =
      Enum.reduce(polylines, {[], polylines}, fn poly, {processed, remain} ->
        {joined, p1, p2} = Enum.find_value(polylines, &join(&1, poly))

        if joined,
          do: {[joined | processed], remain -- [p1, p2]},
          else: {processed, remain}
      end)

    result = {name, kept ++ joined}

    if length(joined) > 0,
      do: join_all(result),
      else: result
  end

  defp join(poly1, poly1), do: {nil, poly1, poly1}

  defp join(poly1, poly2) do
    [s1 | tl1] = poly1
    [s2 | tl2] = poly2
    e1 = List.last(poly1)
    e2 = List.last(poly2)

    joined =
      cond do
        s1 == s2 -> Enum.reverse(tl1) ++ poly2
        s1 == e2 -> poly2 ++ tl1
        s2 == e1 -> poly1 ++ tl2
        e1 == e2 -> poly1 ++ tl(Enum.reverse(poly2))
        true -> nil
      end

    {joined, poly1, poly2}
  end
end
