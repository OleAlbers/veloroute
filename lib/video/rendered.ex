defmodule Video.Rendered do
  # TODO ideally this would be the type of a class implementing the behaviour
  @type t() :: module()

  @autogen_module_name 'Elixir.Data.AutoGenerated.Video.Rendered_'
  @autogen_file_path "data/auto_generated/video"

  @concat_tool "./tools/video_concat.rb"
  @inaccurate_concat ["INACCURATE_CUTS=1", @concat_tool]

  import Video.TrimmedSourceSequence, only: [valid_hash: 1]

  @doc """
  Return a list of all known videos, including the ones without video material
  available.
  """
  @spec all() :: [t()]
  def all() do
    :code.all_available()
    |> Enum.map(&elem(&1, 0))
    |> Enum.filter(&List.starts_with?(&1, @autogen_module_name))
    |> Enum.map(&List.to_atom/1)
    |> Enum.sort()
  end

  @doc """
  Tries to find a fully rendered video for the given hash. It returns nil if
  the hash is invalid, the video cannot be found or has not been rendered yet.
  Note that you need to recompile if videos were rendered in the meantime.
  """
  @spec get(Video.TrimmedSourceSequence.hash() | module()) :: t() | nil
  def get(nil), do: nil

  def get(hash) when valid_hash(hash) do
    rendered() |> Enum.find(fn mod -> String.ends_with?("#{mod}", hash) end)
  end

  def get(%Video.Track{rendered_ref: ref}), do: get(ref)

  def get(module) when is_atom(module), do: if(module.rendered?(), do: module, else: nil)

  def get(_any), do: nil

  @doc """
  Return a list of all videos which have video material available.
  """
  @spec rendered() :: [t()]
  def rendered() do
    all() |> Enum.filter(& &1.rendered?())
  end

  @doc """
  Return a list of all videos for which video material still needs to be generated.
  """
  @spec pending() :: [t()]
  def pending() do
    all() |> Enum.reject(& &1.rendered?())
  end

  @doc """
  Returns the command needed to render the given video(s) in streamable resolutions
  """
  @spec render(t()) :: [binary()]
  def render(rendered) do
    concat =
      Enum.reduce(rendered.sources(), [@concat_tool], fn {path, from, to}, cmd ->
        path = Video.Path.anonymized_rel_to_cwd(path)
        cmd ++ [path, from, to]
      end)

    concat ++
      [
        "|",
        "./tools/video_convert_streamable.rb",
        Video.Path.target_rel_to_cwd(rendered.hash()),
        "#{rendered.length_ms()}"
      ]
  end

  @doc """
  Returns the commands to preview the given video(s). The first item previews
  everything, the following ones just the individual concatting points.
  """
  def preview(rendered, gap_buffer_ms \\ 5_000) do
    player = [
      "|",
      "mpv",
      "--pause",
      "--no-resume-playback",
      "--framedrop=no",
      "--audio=no",
      "--keep-open=yes",
      "--demuxer-max-bytes=10G",
      "--force-seekable=yes",
      "-"
    ]

    concats =
      rendered.sources
      |> Enum.chunk_every(2, 1, :discard)
      |> Enum.map(fn [{path1, _from1, to1}, {path2, from2, _to2}] ->
        path1 = Video.Path.source_rel_to_cwd(path1)
        path2 = Video.Path.source_rel_to_cwd(path2)

        from = to1 |> Video.Timestamp.add_milliseconds(-1 * gap_buffer_ms)
        to = from2 |> Video.Timestamp.add_milliseconds(gap_buffer_ms)

        [@concat_tool, path1, from, to1, path2, from2, to] ++ player
      end)

    full =
      Enum.reduce(rendered.sources, @inaccurate_concat, fn {path, from, to}, cmd ->
        path = Video.Path.source_rel_to_cwd(path)
        cmd ++ [path, from, to]
      end) ++ player

    [full] ++ concats
  end

  @doc """
  Returns the path to the autogenerated video metadata for the given TSV or
  rendered module itself.
  """
  @spec path(Video.TrimmedSourceSequence.t() | t() | %{hash: binary()}) ::
          binary() | {:error, binary()}
  def path(%{hash: hash}) do
    Path.join(@autogen_file_path, "#{hash}.ex")
  end

  def path(module) when is_atom(module) do
    prefix_as_str = to_string(@autogen_module_name)
    mod_as_str = to_string(module)

    if String.starts_with?(mod_as_str, prefix_as_str) do
      hash = String.replace_prefix(mod_as_str, prefix_as_str, "")
      path(%{hash: hash})
    else
      {:error, "#{module} is not a Rendered instance"}
    end
  end

  @doc """
  Render the given trimmed sequence as a rendered video, then save it to disk
  at the matching path.
  """
  @spec save_from_tsv_seq(Video.TrimmedSourceSequence.t()) ::
          :ok | {:error, binary()} | {:error, list(), list()}
  def save_from_tsv_seq(tsv_seq) do
    path = path(tsv_seq)

    with content <- code_from_tsv_seq(tsv_seq),
         :ok <- File.write(path, content),
         {:ok, _modules, _warnings} <- Kernel.ParallelCompiler.compile([path], []) do
      :ok
    end
  end

  @spec module_name(Video.TrimmedSourceSequence.t()) :: module()
  def module_name(tsv_seq) do
    :"#{to_string(@autogen_module_name)}#{tsv_seq.hash}"
  end

  @doc """
  Returns the formatted source code that implements the Video.Rendered behaviour for
  the given trimmed source sequence.
  """
  @spec code_from_tsv_seq(Video.TrimmedSourceSequence.t()) :: iodata()
  def code_from_tsv_seq(tsv_seq) do
    coords = Video.TrimmedSourceSequence.coords(tsv_seq)
    length_ms = coords |> List.last() |> Map.fetch!(:time_offset_ms)
    rendered = Video.Path.fully_rendered?(tsv_seq.hash)
    stream_path = Video.Path.stream_rel_to_cwd(tsv_seq.hash)
    sources = Video.TrimmedSourceSequence.sources(tsv_seq)

    quote do
      defmodule unquote(module_name(tsv_seq)) do
        @moduledoc """
        #{unquote(tsv_seq.name)}

        AUTOGENERATED. To update this file, run mix velo.videos.generate.
        See Video.Rendered for functionality.
        """

        @behaviour Video.Rendered

        @external_resource unquote(stream_path)

        @impl Video.Rendered
        def name(), do: unquote(tsv_seq.name)
        @impl Video.Rendered
        def hash(), do: unquote(tsv_seq.hash)
        @impl Video.Rendered
        def length_ms(), do: unquote(length_ms)
        @impl Video.Rendered
        def sources(), do: unquote(sources)
        @impl Video.Rendered
        def coords(), do: unquote(coords)
        @impl Video.Rendered
        def rendered?(), do: unquote(rendered)
      end
    end
    |> Macro.to_string()
    |> Code.format_string!()
  end

  @callback name() :: binary()
  @callback hash() :: binary()
  @callback length_ms() :: integer()
  @callback sources() :: Video.Track.plain()
  @callback coords() :: [Video.TimedPoint.t()]
  @callback rendered?() :: boolean()
  @doc """
  Outputs the timestamps and coordinates as an iolist, suitable to be passed to the
  frontend for displaying the video position. It returns a flat list with the values
  being time_in_seconds, lon, lat for each point, repeated for all coordinates. The
  caller must take care to iterate through this list by incrementing the index by 3.
  The individual values are floats separated by a space. The first three are the
  original values, thereafter it's the difference to the previous value.

  ## Examples

      iex> Video.Rendered.coord_io_list(Video.RenderedTest.Example)
      '0.0 10.044 53.507 0.1 -0.002 0.001 0.1 -0.002 0.001 0.1 -0.002 0.001 0.1 -0.002 0.001'
  """
  @spec coord_io_list(t()) :: iolist()
  @geo_precision 6
  @time_precision 3
  def coord_io_list(rendered) do
    rendered.coords
    |> Enum.reduce(
      {%Video.TimedPoint{lon: 0, lat: 0, time_offset_ms: 0}, ''},
      fn curr, {prev, acc} ->
        lon = curr.lon - prev.lon
        lat = curr.lat - prev.lat
        ms = curr.time_offset_ms - prev.time_offset_ms

        coord = [
          ' ',
          :erlang.float_to_list(ms / 1000.0, [{:decimals, @time_precision}, :compact]),
          ' ',
          :erlang.float_to_list(lon, [{:decimals, @geo_precision}, :compact]),
          ' ',
          :erlang.float_to_list(lat, [{:decimals, @geo_precision}, :compact])
        ]

        {curr, [acc | coord]}
      end
    )
    |> elem(1)
    |> List.flatten()
    |> tl()
  end

  @spec start_from(t(), Geo.Point.like() | nil) :: %{
          lat: float(),
          lon: float(),
          bearing: float(),
          time_offset_ms: integer()
        }
  @doc """
  Find the closest point for the video that roughly corresponds to the given
  point. If the point is not valid, it returns the start of the video.

  ## Examples

      iex> Video.Rendered.start_from(Video.RenderedTest.Example, %{lat: 53.5085, lon: 10.041})
      %{bearing: 310.0161346069299, lat: 53.5085, lon: 10.041000000000002, time_offset_ms: 150}

      iex> last_coord = Video.RenderedTest.Example.coords |> List.last()
      iex> Video.Rendered.start_from(Video.RenderedTest.Example, last_coord)
      %{bearing: 310.01613460713037, lat: last_coord.lat, lon: last_coord.lon, time_offset_ms: last_coord.time_offset_ms}
  """
  def start_from(rendered, point)

  def start_from(rendered, nil) do
    [a, b | _rest] = rendered.coords
    Map.put(a, :bearing, Geo.CheapRuler.bearing(a, b))
  end

  def start_from(rendered, point) do
    %{point: %{lon: lon, lat: lat}, t: t, index: idx} =
      Geo.CheapRuler.closest_point_on_line(rendered.coords, point)

    {idx, time} =
      if idx == length(rendered.coords) - 1 do
        {idx - 1, Enum.at(rendered.coords, idx).time_offset_ms}
      else
        {idx, nil}
      end

    [prev, next] = Enum.slice(rendered.coords, idx..(idx + 1))
    bearing = Geo.CheapRuler.bearing(prev, next)
    time = time || prev.time_offset_ms + t * (next.time_offset_ms - prev.time_offset_ms)

    %{
      lon: lon,
      lat: lat,
      bearing: bearing,
      time_offset_ms: round(time)
    }
  end
end
